# Курсовая работа по программированию за 1 курс

## Задание:
Программа должна поддерживать систему меню,
пункты которых соответствуют выполнению функций,
предусмотренных общей частью задания.
Предлагаемые структуры данных должны учитывать
изначальную неопределенность возможного количества групп и студентов в группах.

### Необходимо
1) Разработать (и программно реализовать) динамические структуры данных
   (односвязные списки) и алгоритмы их обработки,
   позволяющие поддерживать выполнение следующих функций:
    - консольный ввод/вывод данных о всех студентах потока;
    - файловый ввод/вывод данных о потоке;
    - редактирование данных о студентах и группах потока,
      включающее операции добавления/удаления групп и студентов;
3) Разработать и реализовать алгоритмы обработки базы данных, предусмотренные персональным заданием.

### Персональные задания
1) Вывести на экран номера всех групп, не имеющих двоечников,
   в порядке убывания среднего (по группе) балла;
2) Вывести перечень групп, упорядоченный по значению показателя
   «процент должников» (с указанием значения показателя).

### Описание структур данных
Программа включает в себя два односвязных списка: `Student` и `Group`

`Student` содержит:
- `name` - ФИО (до 50 символов);
- `group` - номер группы;
- `marks[5]`набор из пяти оценок за последнюю сессию (без указания предметов);
- `scholarship` - размер стипендии.

`Group` содержит:
- `number` - номер группы;
- `student` - указатель на список студентов;
- `next` - указатель на следующую группу.

### Описание функций для персональных заданий
- Функция `without_twos` - вывод номеров всех групп, не имеющих двоечников,
  в порядке убывания среднего (по группе) балла:
```c++ 
void without_twos(Group* tmp) {
    bool log;
    int i, j;
    float sred, sum, kol;
    vector<float> sr_ball; // вектор для среднего балла в подходящих группах  
    vector<int> groups; // вектор для номеров подходящих групп

    while (tmp != nullptr) { // обходим все группы
        // запоминаем указатель на первого студента в группе
        // т.к. в процессе перебора студентов он будет изменяться
        Student* ptr = tmp->student;

        kol = 0;
        log = true;
        sum = 0;
        while (tmp->student != nullptr) { // смотрим всех студентов в группе            
            for (i = 0; i < 5; ++i) {
                if (tmp->student->marks[i] <= 2) break; // если встретилась двойка, то выходим из цикла             
                sum += tmp->student->marks[i]; // считаем сумму оценок студента
            }
            kol++; // считаем количество студентов
            if (i < 5) { // если встретилась двойка (цикл for не доработал до конца)
                log = false;
                break;                
            }
            tmp->student = tmp->student->next; // переходим к следующему студенту
        }
        if (log) { // если в группе нет двоечников
            sred = sum / (5 * kol); // считаем средний балл
            sr_ball.push_back(sred); //добавляем в вектор средних баллов посчитаный ранее балл
            groups.push_back(tmp->number); // добавляем группу в вектор групп
            // получилось, что номер группы и её средний балл имеют одинаковый индекс в векторах
        }
        tmp->student = ptr; // восстанавливаем указатель на первого студента в группе
        tmp = tmp->next; // переходим к следующей группе
    }

    if (sr_ball.empty()) {
        cout << "\nТаких групп нет\n";
        return;
    }
    
    // создаем массив индексов
    vector<int> index(groups.size()); 
    for (i = 0; i < groups.size(); ++i) index[i] = i;

    // сортировка пузырьком вектора средних баллов 
    // параллельно значения в индексном массиве тоже переставляются
    // по итогу значения в индексном массиве соответствуют индексам групп по убыванию среднего балла
    for (i = 0; i + 1 < sr_ball.size(); ++i) {
        for (j = 0; j + 1 < sr_ball.size() - i; ++j) {
            if (sr_ball[j] < sr_ball[j + 1]) {
                swap(sr_ball[j], sr_ball[j + 1]);
                swap(index[j], index[j + 1]);
            }
        }
    }

    // выводим подходящие группы и значение среднего балла
    cout << "\nГруппа -- средний балл:\n";
    for (i = 0; i < index.size(); ++i) {
        cout << " " << groups[index[i]] << " -- " << sr_ball[i] << endl;
    }
}
```
- Функция `dolg` - вывод переченя групп, упорядоченных по значению показателя
  «процент должников» (с указанием значения показателя).
```c++
void dolg(Group* curr) {
    int i, j;
    float dolg, kol;
    vector<float> pers_dolg; // вектор для значений "процент должников"
    vector<int> groups; // вектор для номеров групп 

    while (curr != nullptr) {
        // запоминаем указатель на первого студента в группе
        // т.к. в процессе перебора студентов он будет изменяться
        Student* ptr = curr->student;

        kol = 0;
        dolg = 0;
        while (curr->student != nullptr) {
            for (i = 0; i < 5; ++i) {
                if (curr->student->marks[i] <= 2) break;
            }
            kol++; // считаем кол-во студентов в группе
            if (i < 5) dolg++; // если у студента есть двойка или меньше (т.е. цикл for не доработал до конца), то записывем студента в должники
            curr->student = curr->student->next; // переходим к следующему студенту
        }   
        groups.push_back(curr->number); // добавляем группу в вектор групп
        pers_dolg.push_back(100 * dolg / kol); // добавляем в вектор "процент должников" для данной группы
        // получилось, что номер группы и её "процент должников" имеют одинаковый индекс в векторах

        curr->student = ptr; // восстанавливаем указатель на первого студента в группе
        curr = curr->next; // переходим к следующей группе
    }

    // создаем массив индексов
    vector<int> index(groups.size());
    for (i = 0; i < groups.size(); ++i) index[i] = i;

    // сортировка пузырьком вектора значений "процент должников" 
    // параллельно значения в индексном массиве тоже переставляются
    // по итогу значения в индексном массиве соответствуют порядку групп по убыванию процента должников
    for (i = 0; i + 1< pers_dolg.size(); ++i) {
        for (j = 0; j + 1 < pers_dolg.size() - i; ++j) {
            if (pers_dolg[j] < pers_dolg[j + 1]) {
                swap(pers_dolg[j], pers_dolg[j + 1]);
                swap(index[j], index[j + 1]);
            }
        }
    }

    // выводим подходящие группы и значение "процент должников"
    cout << "\nГруппа -- процент должников:\n";
    for (i = 0; i < index.size(); ++i) {
        cout << " " << groups[index[i]] << " -- " << pers_dolg[i] << "%" << endl;
    }
}
```
